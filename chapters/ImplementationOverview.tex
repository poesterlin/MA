\chapter{Implementation Overview}
\label{cha:ImplementationOverview}
A big problem early on in the development of the detection algorithm was caused by how different human hands can be. The detection had to be accurate enough to decide between stored gestures based only on one finger being in a different position, while staying flexible enough so a user could adjust their hands posture or simply have their own interpretation of the gesture. This turned out to be quite difficult to implement. The final implementation took the following approaches to improve the detection accuracy and speed.

\section{Calibration}
In order to make the detection more universally accurate to all hand sizes, the system first measures the size of the user's hand. This is achieved by adding up the distance from the wrist joint up to the tip of the middle finger. It was found that this is an accurate enough and very consistent method. The output value of the size calibration allows the detection system to scale the joint positions up or down depending on the users hand size. This improves the accuracy of the detection. In the current implementation this can not be done universally for every user however. In some cases the distances between the gesture states are simply too small to be able to handle the differences in anatomy or execution style that are still present after the size calibration. This lead to inaccurate detections early on in testing which is frustrating for the user to experiences. Therefor an explicit calibration step was added that would record the users input for every gesture state before it can be used in order to optimize the detection. The recorded ground truth is stored in the system and is used together with previously stored joint positions in order to be able to detect the gesture state accurately. The size calibration also helps in this case since the positions are all on a universal scale. The previously stored variants are first tested if they would lead to a wrong detection when compared to the ground truth and filtered out automatically if they are not compatible to the current user. This improves the accuracy, keeps the calibration short and provides the user with a high degree of flexibility since they can rely on the calibration input of other, compatible users if they do not execute a gesture change perfectly similar to the calibration run or just naturally shift the way they are gesturing during use.

\section{Gesture Recognition}
A gesture system has multiple assigned states mapped to different actions like aiming and confirming a teleport location. In the current use case, the states are not completely different however. Depending on the gesture system, there is sometimes a lot of overlap between the states. This allows for some optimization in the algorithm. The detection system first compares the joint positions of the joints that are the same in all states. A distance to the stored base version of the gesture system is computed and compared to a threshold to be able to tell if the user is currently presenting a gesture. This threshold was set after a lot of experimentation, but can also be changed dynamically if there should be any problems with the detection. After the system has determined if the static joints are in the right position for a gesture, the next step is to analyse what state the gesture is in. For this, the system runs through all variants that are available after the calibration step. The variant with the smallest distance to the tracked gesture is recorded. The distance needs to be under a second threshold for the variant to be considered. This threshold is calculated per user during the calibration step based on the ground truth recordings. If a variant passes all checks, it is first stored locally inside the recognition system until it is recognized consistently for $0.5$ seconds. After this last check is completed, the detection system uses the information included in the variants data about what state it is assigned to and passes that information on. It was found during testing that this time threshold filters out false positive recognitions effectively, while still allowing for fast trigger times.
